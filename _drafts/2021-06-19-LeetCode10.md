---
layout: post
title: Week 10 LeetCode
tags: [Algorithm,LeetCode]
---
# LeetCode: Week 10
> :star: : Hard Coding or Easy
>
> :star::star: : Basic Question
>
> :star::star::star: : Twisted but worthy
>
> :star::star::star::star:: Discerning

## [138. Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/) :star::star:

### Map

Time Complexity: $$O(N)$$

Space Complexity: $$O(N)$$

**Key-Point**:  Pairing


```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x, next=None, random=None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        
        headRoot = Node(0)
        curNewNode = headRoot
        curOriNode = head
        
        #key: node reference, value: node 
        menu = {}        
        
        # constructing skeleton linked list (random pointer is empty)
        while curOriNode:
            
            curNewNode.next = Node(curOriNode.val)
            
            menu[curOriNode] = curNewNode.next
            curNewNode = curNewNode.next
            curOriNode = curOriNode.next
                     
        
        curNewNode = headRoot
        curOriNode = head
        
        # fill up radom pointer from menu
        while curOriNode:
            if curOriNode.random == None:
                curNewNode.next.random = None
            else:
                curNewNode.next.random = menu[curOriNode.random]
            curNewNode = curNewNode.next
            curOriNode = curOriNode.next
            
    
        return headRoot.next

```

## [139. Word Break](https://leetcode.com/problems/word-break/) :star::star:

### DP

Time Complexity: $$O(N^2)$$

Space Complexity: $$O(N)$$

**Key-Point**:  dp\[i] means s\[:i+1] can be segmented into words in the wordDicts 
* dp\[0\] is always True and size of dp is n+1.
* If Previous segements are in ``wordDict``(dp\[i\] == True), check if s\[i+1:~len(s)] is in wordDict.


```python
class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        # First element is dummy value 
        dp = [False for _ in range(len(s)+1)]
        dp[0] = True

        for i in range(len(s)):
            # if previous segment is not in wordDict, we break
            if not dp[i]:
                continue
            
            for j in range(i, len(s)):
                   
                # if previous segment is valid, and current segment is valid, we set dp[j+1] as true
                if s[i:j+1] in wordDict:
                    dp[j+1] = True
                
        return dp[-1]
```

## [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) :star:

### Equi-Directional

Time Complexity: $$O(N)$$

Space Complexity: $$O(N)$$

**Key-Point**: Use Fast and slow pointer to check cycle


```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        memo = set()
        
        curHead = head
        
        while curHead:
            
            if curHead in memo:
                return curHead
            
            memo.add(curHead) 
            curHead = curHead.next
            
            
        return None
            
```

## [143. Reorder List](https://leetcode.com/problems/reorder-list/) :star: :star:

### Split, Last and Merge

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-Point**: Two Pointer


```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reorderList(self, head):
        """
        :type head: ListNode
        :rtype: None Do not return anything, modify head in-place instead.
        """
        
        firstNode = head
        secondNode = head
        
        while secondNode.next and secondNode.next.next:
            firstNode = firstNode.next
            secondNode = secondNode.next.next
            
        
        secondHalfList = []
        curNode = firstNode.next
        while curNode:
            secondHalfList.append(curNode)
            curNode = curNode.next
        
        curNode = head
        
        for node in secondHalfList[::-1]:
            node.next = curNode.next
            curNode.next = node
            curNode = curNode.next.next
            
            
        curNode.next = None
```


## [146. LRU Cache](https://leetcode.com/problems/lru-cache/) :star: :star:

### Using Oredered Dictionary

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-Point**: Use ordered dictionary from collections


```python
class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.maxCapacity = capacity
        self.storage = collections.OrderedDict()

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key in self.storage:
            # update ordered dictionary for LRU
            value = self.storage.pop(key)
            self.storage[key]  = value
            return value
        else:
            return -1
        

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        if key in self.storage:
            self.storage.pop(key)
        elif len(self.storage) == self.maxCapacity:
            self.storage.popitem(last = False) # FIFO
        self.storage[key] = value

```

## [147. Insertion Sort List](https://leetcode.com/problems/insertion-sort-list/) :star: :star: :star:

### Using Oredered Dictionary

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-Point**: Use ordered dictionary from collections


```python

```

## [148. Sort List](https://leetcode.com/problems/sort-list/) :star: :star: :star:

### Using Oredered Dictionary

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-Point**: Use ordered dictionary from collections


```python
