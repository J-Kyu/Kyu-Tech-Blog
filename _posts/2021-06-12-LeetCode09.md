---
layout: post
title: Week 9 LeetCode
tags: [Algorithm,LeetCode]
---
# LeetCode: Week 9
> :star: : Hard Coding or Easy
>
> :star::star: : Basic Question
>
> :star::star::star: : Twisted but worthy
>
> :star::star::star::star:: Discerning

## [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/) :star::star:

### Start From Border

Time Complexity: $$O(N^2)$$

Space Complexity: $$O(1)$$

**Key-Point**:  Star from border side. Any grid that is related to boarder 'O', flip it into  '-'. At the end filp all the '-' to 'O' and flip rest into 'X'.


```python
class Solution(object):
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        row = len(board)
        column = len(board[0])
        
        
        def Flip(board,r,c):
            
            if r < 0  or r >= row or c < 0 or c >= column:
                return
            
            if board[r][c] != 'O':
                return
            
            board[r][c] = '-'
            
            dir = [[1,0],[-1,0],[0,1],[0,-1]]
            for i in dir:
                Flip(board,r+i[0],c+i[1])
                
        
        #  hem
        for i in range(column):
            
            Flip(board,0,i)
            Flip(board,row-1,i)
            
        for i in range(1,row-1):
            Flip(board,i,0)
            Flip(board,i,column-1)
            
        for i in range(row):
            for j in range(column):
                if board[i][j] != '-':
                    board[i][j] = 'X'
                else:
                    board[i][j] = 'O'
                
                    
            
       

```

## [131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/) :star::star::star:

### DFS

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-Point**:  Backtraking (use parition)


```python
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        
        ans = []
        def DFS(substring,temp,ans):
            
            if len(substring) == 0:
                ans.append(temp)
                return
            
            for i in range(len(substring)):
                tempStr = substring[:i+1] 
                if tempStr == tempStr[::-1]:
                    DFS(substring[i+1:],temp+[tempStr],ans)
                    
        DFS(s,[],ans)
        return ans

```

### DP

Time Complexity: $$O()$$

Space Complexity: $$O()$$

**Key-Point**:  We go throught the list by DFS but uuse dp for checking palindrome.


```python
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        n = len(s)
        dp = [[False for _ in range(n)] for _ in range(n)]
        result = []
        self.DFS(result,s,0,[],dp)
        return result
    
    def DFS(self,rs,s,start,currentList,dp):
        if start >= len(s):
            rs.append(currentList)
            return

            
        for end in range(start, len(s)):
            if s[start] == s[end] and (end-start <= 2 or dp[start+1][end-1]):
                dp[start][end] = True
                self.DFS(rs,s,end+1,currentList+[s[start:end+1]],dp)

```


## [134. Gas Station](https://leetcode.com/problems/gas-station/) :star::star:

### Greedy

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-Point**: 
1. Check whether given condition is valid.
> If valid, which means there is solutin, we have to find the start poin
2. By given order, we see if given gas at the each station can afford the cost.
3.  If the gas cannot afford the cost, it means the station caanot be the start station.
> However, since we know there is a solution, we move on to next station to find start point.


```python
class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """
        if sum(gas) < sum(cost): 
            return -1
        n, start, agg = len(gas), 0, 0
        for i in range(n):
            agg += gas[i] - cost[i]
            if agg < 0:
                start, agg = i+1, 0
        return start

```


## [137. Single Number II](https://leetcode.com/problems/single-number-ii/) :star::star:

### Counter

Time Complexity: $$O(N)$$

Space Complexity: $$O(1)$$

**Key-Point**:  Count every single value of number


```python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = Counter(nums)
        for key in dic.keys():
            if dic[key] == 1:
                return key
            
        return -1
```
